{
  "asia should emit TypeError if title is not a string": {
    "skip": false,
    "todo": false,
    "run": false,
    "isPending": false,
    "isRejected": false,
    "isFulfilled": true,
    "id": 1,
    "str": "(t) => {\n  let called = false;\n  function emit(name, meta, { reason: err }) {\n    t.ok(err.message.includes('expect `title`'));\n    called = true;\n  }\n\n  const asia = api(emit);\n\n  asia(123);\n  t.ok(called);\n}",
    "title": "asia should emit TypeError if title is not a string"
  },
  "asia should emit TypeError if testFn is not a function": {
    "skip": false,
    "todo": false,
    "run": false,
    "isPending": false,
    "isRejected": false,
    "isFulfilled": true,
    "id": 2,
    "str": "(t) => {\n  let called = false;\n  function emit(name, meta, { reason: err }) {\n    t.ok(err.message.includes('expect `testFn`'));\n    called = true;\n  }\n\n  const asia = api(emit);\n\n  asia('foo bar baz');\n  t.ok(called);\n}",
    "title": "asia should emit TypeError if testFn is not a function"
  },
  "asia.run should run the tests in parallel": {
    "skip": false,
    "todo": false,
    "run": false,
    "isPending": false,
    "isRejected": false,
    "isFulfilled": true,
    "id": 3,
    "str": "async (t) => {\n  const asia = api(() => {}, { snapshots: false });\n  let count = 0;\n\n  asia('yeah passing', (tAssert) => {\n    tAssert.ok(true);\n    count += 1;\n  });\n\n  asia.todo('test without implementation');\n\n  asia.skip('skipping test, yeah', () => {});\n\n  asia('some failing test', (tAssert) => {\n    count += 1;\n    tAssert.ok(false);\n  });\n\n  await t.nextTick(async () => {\n    const { stats } = await asia.run();\n\n    t.strictEqual(stats.count, 4);\n    t.strictEqual(stats.pass, 1);\n    t.strictEqual(stats.fail, 1);\n    t.strictEqual(stats.skip, 1);\n    t.strictEqual(stats.todo, 1);\n    t.strictEqual(count, 2);\n  });\n}",
    "title": "asia.run should run the tests in parallel"
  },
  "asia.run should run tests in series": {
    "skip": false,
    "todo": false,
    "run": false,
    "isPending": false,
    "isRejected": false,
    "isFulfilled": true,
    "id": 4,
    "str": "async (t) => {\n  const asia = api(() => {}, { snapshots: false, concurrency: 1 });\n  const arr = [];\n\n  asia('foo bar', () => {\n    arr.push(1);\n  });\n  asia('second', () => {\n    arr.push(2);\n  });\n\n  await t.nextTick(async () => {\n    await asia.run();\n    t.strictEqual(arr.length, 2);\n    t.strictEqual(arr[0], 1);\n    t.strictEqual(arr[1], 2);\n  });\n}",
    "title": "asia.run should run tests in series"
  },
  ".todo should emit TypeError if pass implementation function": {
    "skip": false,
    "todo": false,
    "run": false,
    "isPending": false,
    "isRejected": false,
    "isFulfilled": true,
    "id": 5,
    "str": "(t) => {\n  let called = false;\n  function emit(name, meta, { reason: err }) {\n    t.ok(err.message.includes('todo does expect only title'));\n    called = true;\n  }\n  const asia = api(emit, { snapshots: false });\n\n  asia.todo('foo bar', () => {});\n  t.ok(called);\n}",
    "title": ".todo should emit TypeError if pass implementation function"
  },
  "should emit TypeError if options.match is not a string if given": {
    "skip": true,
    "todo": false,
    "run": false,
    "isPending": false,
    "isRejected": false,
    "isFulfilled": true,
    "id": 6,
    "str": "(t) => {\n  let called = false;\n  function emit(name, meta, { reason: err }) {\n    t.ok(err.message.includes('options.match should be string, when given'));\n    called = true;\n  }\n\n  const asia = api(emit, { match: ['t*', '*e'], snapshots: false });\n\n  asia('one', () => {});\n  asia('two', () => {});\n  asia('three', () => {});\n  t.ok(called);\n}",
    "title": "should emit TypeError if options.match is not a string if given"
  },
  "should run only tests that match given glob pattern": {
    "skip": false,
    "todo": false,
    "run": false,
    "isPending": false,
    "isRejected": false,
    "isFulfilled": true,
    "id": 7,
    "str": "async (t) => {\n  const asia = api(() => {}, { match: '*b*', snapshots: false });\n  let count = 0;\n\n  asia('abc', (tst) => {\n    tst.ok(true);\n    count += 1;\n  });\n  asia('adef', (tst) => {\n    tst.ok(true);\n    count += 1;\n  });\n  asia('abar', (tst) => {\n    tst.ok(true);\n    count += 1;\n  });\n\n  await t.nextTick(async () => {\n    const { stats } = await asia.run();\n\n    t.strictEqual(count, 2);\n    t.strictEqual(stats.count, 3);\n    t.strictEqual(stats.pass, 2);\n  });\n}",
    "title": "should run only tests that match given glob pattern"
  },
  "should have hooks - before, beforeEach, afterEach, after": {
    "skip": true,
    "todo": false,
    "run": false,
    "isPending": false,
    "isRejected": false,
    "isFulfilled": true,
    "id": 8,
    "str": "async (t) => {\n  const calls = {};\n  const asia = api(() => {}, { snapshots: false });\n\n  asia.before(() => {\n    calls.before = true;\n  });\n  asia.beforeEach(() => {\n    t.ok(calls.before, 'the \"before\" should be called previously');\n    calls.beforeEach = true;\n  });\n  asia('foo bar baz', () => {\n    t.ok(calls.beforeEach, 'the \"beforeEach\" hook should be called previously');\n    calls.test = true;\n  });\n  asia.afterEach(() => {\n    t.ok(calls.test, 'the test should be called before the \"afterEach\" hook');\n    calls.afterEach = true;\n  });\n  asia.after(() => {\n    t.ok(calls.afterEach, 'the \"afterEach\" hook should be called previously');\n    calls.after = true;\n  });\n\n  await t.nextTick(async () => {\n    const { stats } = await asia.run();\n\n    t.ok(stats.count === 1);\n    t.ok(stats.pass === 1);\n\n    t.deepEqual(calls, {\n      before: true,\n      beforeEach: true,\n      test: true,\n      afterEach: true,\n      after: true,\n    });\n  });\n}",
    "title": "should have hooks - before, beforeEach, afterEach, after"
  },
  "should work for Observables": {
    "skip": false,
    "todo": false,
    "run": false,
    "isPending": false,
    "isRejected": false,
    "isFulfilled": true,
    "id": 9,
    "str": "async (t) => {\n  let called = 0;\n  const asia = api(() => {}, { snapshots: false });\n\n  asia('some test returning observable', () => {\n    const observable = Observable.of(1, 2, 3, 4, 5, 6);\n\n    return observable\n      .filter(\n        (n) =>\n          // Only even numbers\n          n % 2 === 0,\n      )\n      .map((v) => {\n        called += 1;\n        return v;\n      });\n  });\n\n  await t.nextTick(async () => {\n    const { stats, results } = await asia.run();\n\n    t.strictEqual(called, 3);\n    t.strictEqual(stats.pass, 1);\n    t.strictEqual(stats.count, 1);\n    t.deepStrictEqual(results[0].value, [2, 4, 6]);\n  });\n}",
    "title": "should work for Observables"
  }
}